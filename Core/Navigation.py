# -*- coding: UTF-8 -*- """---------------------------------------------------------------------------- Author:    caodahan97@126.com Date:    2019/05/29 Description: 	A* path finding算法, 用heap实现版本 	quick guide: 	start = Node(None, 20, 20) 	end = Node(None, 50, 30) 	print findPath(start, end)  # return path list	It reads a map in the beginning of this script. History: ----------------------------------------------------------------------------"""import timefrom heapq import heappush, heappop_2dmap = []  # 地图对应二维数组mapBorder = ()  # 长宽上限gCloseList = {}class Node:	def __init__(self, father, x, y, end=None):		# 检查边界（最外层为0）		if x < 0 or x >= mapBorder[0] or y < 0 or y >= mapBorder[1]:			raise Exception("node position can't beyond the border!")		self.father = father		self.x = x		self.y = y		if father is not None:			G2father = calcG(father, self)			if not G2father:				raise Exception("father is not valid!")			self.G = G2father + father.G			self.H = calcH(self, end)			self.F = self.G + self.H  # 初始化的时候计算出F 		else:  # it has no father, thus it is the start point 			self.G = 0			self.H = 0			self.F = 0	def __lt__(self, other):		"""先简单的写个比较运算"""		return True	def resetFather(self, father, newG):		if father is not None:			self.G = newG			self.F = self.G + self.H		self.father = fatherdef calcG(start, cur):  # 该点	"""计算G值"""	dx = abs(start.x - cur.x)	dy = abs(start.y - cur.y)	if dx == 1 and dy == 0:		return 10  # same row 	if dx == 0 and dy == 1:		return 10  # same col 	if dx == 1 and dy == 1:		return 14  # cross 	else:		return 0def calcH(cur, end):	"""估算该点到终点距离(忽略墙等阻挡物), 采用Manhattan distance"""	return 10 * (abs(end.x - cur.x) + abs(end.y - cur.y))def aStarCore(heap, openList, closeList, node, end):	# 将该节点从开放列表移到关闭列表当中。 	openList.pop((node.x, node.y))  # key 为(x, y)形式的坐标tuple	closeList[(node.x, node.y)] = node	adjacentList = []  # 相邻点列表	# 加入领接点。地图的layout的边界需要用0进行标记, 否则会进入except	try:		adjacentList.append(Node(node, node.x, node.y - 1, end))		adjacentList.append(Node(node, node.x + 1, node.y, end))		adjacentList.append(Node(node, node.x, node.y + 1, end))		adjacentList.append(Node(node, node.x - 1, node.y, end))	except Exception as e:		print(e)		print(("adjacentList append error!", (node.x, node.y)))		raise	# 用heap二叉堆作为数据结构实现	for adjNode in adjacentList:		if (adjNode.x, adjNode.y) == (end.x, end.y):			newG = calcG(adjNode, node) + node.G			end.resetFather(node, newG)			# "End point reached!"			return True		if (adjNode.x, adjNode.y) in closeList:  # 墙体等部分也在close_list中, 因此不会被认为是可以考虑的结点			continue		if (adjNode.x, adjNode.y) not in openList:			openList[(adjNode.x, adjNode.y)] = adjNode			heappush(heap, (adjNode.F, adjNode))		else:  # those nodes in openList			existNode = openList[(adjNode.x, adjNode.y)]			newG = calcG(adjNode, node) + node.G			if newG < existNode.G:				existNode.resetFather(node, newG)				# how to update the value in heap? we can push this node into it, and try to clean the heap top later 				# 因此, heap取出最小值的时候会检查是否已经在closeList中				heappush(heap, (existNode.F, existNode))	return Falsedef retrieveLastNode(start, end):	"""	这个函数用来循环推断end点，当到最后一个end点时即完成寻路	need to use end node to extract result	:param start:	:param end:	:return:end点	"""	openList = {}	closeList = dict(gCloseList)	# 若结点在Close表中	if (start.x, start.y) in list(gCloseList.keys()):		print("start in block area")		return end	if (end.x, end.y) in list(gCloseList.keys()):		print("end in block area")		return end	openList[(start.x, start.y)] = start	heap = []	theNode = start	try:		while not aStarCore(heap, openList, closeList, theNode, end):			# only return True when destination reached			F, theNode = heappop(heap)			while (theNode.x, theNode.y) in list(closeList.keys()):				"""the_node是已经走过了的点的话, 丢弃了再抽出一个新的the_node,出现这个代码的原因是addAdjacentIntoOpen_new最后一个				else语句中为了实现decreaseKey的操作, 直接塞入了新的结点, 而没有删除老的结点 这个操作一旦发生, 我们的Q中会出现重复的结点. 				因此这里必须检查一下是否新取出的heapTop结点是已经在close_list中的走过的结点 """				F, theNode = heappop(heap)	except Exception as e:		print(e)		raise	return enddef findPath(start, end):	"""	这个函数即为寻路的核心接口	return a path list of points from start to end	:param start:	:param end:	:return:path，失败为None	"""	serializedList = []	print("寻路: start:", (start.x, start.y), " end:", (end.x, end.y))	end = retrieveLastNode(start, end)	if end.father:  # 如果没推算出来就是None了		serializePath(end.father, serializedList)		serializedList.reverse()  # 逆序，从而变为起点到终点的路径		return serializedList	else:		return None# =======================================================================def markPath(node):	if node.father is None:  # start point		return	_2dmap[node.x][node.y] = '#'	markPath(node.father)def serializePath(node, serializedList):	"""	由node点推算出一条序列化的路径保存到serializedList中，使用的办法是递归，将node点挨个存入	extract result to a path list containing all the points orderly	:param node:	:param serializedList:	:return:	"""	if node.father is None:		return	serializedList.append((node.x, node.y))	serializePath(node.father, serializedList)def readMap(filepath):	# 读取文件信息	global mapBorder	f = open(filepath, 'r')	line = f.readline()	line = f.readline()	line = f.readline()	line = f.readline()	# 将地图数据转为二维list	for line in f:		line = line[1:-3].replace(',', '')  # 变为01序列		l = list(line)		_2dmap.append(l)	mapBorder = (len(_2dmap), len(_2dmap[0]))  # 得到border	rowIndex = 0	for row in _2dmap:		colIndex = 0		for n in row:			if n == '0':  # 0 for block, not reachable				blockNode = Node(None, colIndex, rowIndex)  # 要非常注意x=col_index, y=row_index				gCloseList[(blockNode.x, blockNode.y)] = blockNode			colIndex = colIndex + 1		rowIndex = rowIndex + 1def TransformPathList(pathList):	# 参数是astar算法得到的路径列表，我们将其转回原坐标系坐标	if pathList:		# print(("Path:", pathList))		return [(p[0] - 17.0, 0, 36.0 - p[1]) for p in pathList]	else:		return []def Navigate(start, end):	"""	寻路	:param start: vector3-xyz	:param end: vector3-xyz	:return:	"""	# 为了将负数点转正需要x+17,而z最大不会超过36，因此最后得到的是以(-17,36)点为坐标原点（0点）的相对坐标<（60,60）	start = Node(None, int(round((start["PosX"] + 17.0))), int(round((36.0 - start["PosZ"]))))	end = Node(None, int(round((end["PosX"] + 17.0))), int(round((36.0 - end["PosZ"]))))	# 计算出来后再将坐标转回来	pathList = TransformPathList(findPath(start, end))	return pathListreadMap('map.txt')  # read map in the beginning